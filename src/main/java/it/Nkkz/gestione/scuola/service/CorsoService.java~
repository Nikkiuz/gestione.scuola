package it.Nkkz.gestione.scuola.service;

import it.Nkkz.gestione.scuola.dto.*;
import it.Nkkz.gestione.scuola.entity.*;
import it.Nkkz.gestione.scuola.repository.AulaRepository;
import it.Nkkz.gestione.scuola.repository.CorsoRepository;
import it.Nkkz.gestione.scuola.repository.InsegnanteRepository;
import it.Nkkz.gestione.scuola.repository.StudenteRepository;
import jakarta.persistence.EntityNotFoundException;
import org.springframework.beans.BeanUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.*;
import java.util.stream.Collectors;

@Service
public class CorsoService {

	@Autowired
	private CorsoRepository corsoRepository;

	@Autowired
	private StudenteRepository studenteRepository;

	@Autowired
	private AulaRepository aulaRepository;

	@Autowired
	private InsegnanteRepository insegnanteRepository;

	private Map<Long, List<Studente>> listaDiAttesa = new HashMap<>();

	//Recupera tutti i corsi attivi (Admin)
	public List<CorsoResponseDTO> getTuttiICorsi() {
		return corsoRepository.findByAttivoTrue().stream()
			.map(this::convertToResponseDTO)
			.collect(Collectors.toList());
	}

	//Recupera i corsi di un insegnante
	public List<CorsoResponseDTO> getCorsiByInsegnante(Long insegnanteId) {
		return corsoRepository.findByInsegnanteIdAndAttivoTrue(insegnanteId).stream()
			.map(this::convertToResponseDTO)
			.collect(Collectors.toList());
	}

	public CorsoResponseDTO getCorsoById(Long id) {
		Corso corso = corsoRepository.findById(id)
			.orElseThrow(() -> new EntityNotFoundException("Corso non trovato con ID: " + id));
		return convertToResponseDTO(corso);
	}


	//Recupera corsi per giorno e orario
	public List<CorsoResponseDTO> getCorsiByGiornoEOrario(String giorno, String orario) {
		return corsoRepository.findByGiornoAndOrarioAndAttivoTrue(giorno, orario).stream()
			.map(this::convertToResponseDTO)
			.collect(Collectors.toList());
	}

	//Recupera corsi per lingua e livello (ORA SENZA STRINGHE)
	public List<CorsoResponseDTO> getCorsiByLinguaELivello(String lingua, Livello livello) {
		return corsoRepository.findByLinguaAndLivelloAndAttivoTrue(lingua, livello).stream()
			.map(this::convertToResponseDTO)
			.collect(Collectors.toList());
	}

	//Recupera corsi per tipologia (privati o di gruppo)
	public List<CorsoResponseDTO> getCorsiByTipologia(String tipoCorso) {
		return corsoRepository.findByTipoCorsoAndAttivoTrue(tipoCorso).stream()
			.map(this::convertToResponseDTO)
			.collect(Collectors.toList());
	}

	//Crea un nuovo corso
	public CorsoResponseDTO creaCorso(CorsoRequestDTO request) {
		Optional<Aula> aulaOpt = aulaRepository.findById(request.getAulaId());
		if (aulaOpt.isEmpty()) {
			throw new EntityNotFoundException("Aula non trovata con ID: " + request.getAulaId());
		}

		Aula aula = aulaOpt.get();

		// ⚠️ Controlla se l'aula è già occupata per giorno e orario
		List<Corso> corsiEsistenti = corsoRepository.findByAulaIdAndGiornoAndOrarioAndAttivoTrue(
			aula.getId(), request.getGiorno(), request.getOrario());

		if (!corsiEsistenti.isEmpty()) {
			throw new IllegalStateException("L'aula è già occupata per il giorno " + request.getGiorno() +
				" alle " + request.getOrario());
		}

		Corso corso = new Corso();
		BeanUtils.copyProperties(request, corso);
		corso.setSecondoGiorno(request.getSecondoGiorno());
		corso.setSecondoOrario(request.getSecondoOrario());
		corso.setAula(aula);
		corso.setStudenti(studenteRepository.findAllById(request.getStudentiIds()));
		corso.setAttivo(true);

		corsoRepository.save(corso);
		return convertToResponseDTO(corso);
	}


	//Modifica un corso esistente
	public CorsoResponseDTO modificaCorso(Long id, CorsoRequestDTO request) {
		Corso corso = corsoRepository.findById(id)
			.orElseThrow(() -> new EntityNotFoundException("Corso non trovato"));

		Optional<Aula> aulaOpt = aulaRepository.findById(request.getAulaId());
		if (aulaOpt.isEmpty()) {
			throw new EntityNotFoundException("Aula non trovata con ID: " + request.getAulaId());
		}
		Aula aula = aulaOpt.get();

		// ⚠️ Controlla che non ci siano altri corsi nella stessa aula, giorno e orario
		List<Corso> corsiEsistenti = corsoRepository.findByAulaIdAndGiornoAndOrarioAndAttivoTrue(
			aula.getId(), request.getGiorno(), request.getOrario());

		boolean sovrapposto = corsiEsistenti.stream()
			.anyMatch(c -> !c.getId().equals(corso.getId())); // Ignora se stesso

		if (sovrapposto) {
			throw new IllegalStateException("Impossibile modificare: l'aula è già occupata per quel giorno/orario.");
		}

		BeanUtils.copyProperties(request, corso, "id");
		corso.setSecondoGiorno(request.getSecondoGiorno());
		corso.setSecondoOrario(request.getSecondoOrario());
		corso.setAula(aula);
		corso.setStudenti(studenteRepository.findAllById(request.getStudentiIds()));

		corsoRepository.save(corso);
		return convertToResponseDTO(corso);
	}


	//Interrompi un corso (senza eliminarlo)
	public void interrompiCorso(Long id) {
		Corso corso = corsoRepository.findById(id)
			.orElseThrow(() -> new EntityNotFoundException("Corso non trovato"));

		corso.setAttivo(false);
		corsoRepository.save(corso);
	}

	//Elimina definitivamente un corso
	public void eliminaCorso(Long id) {
		Corso corso = corsoRepository.findById(id)
			.orElseThrow(() -> new EntityNotFoundException("Corso non trovato"));

		corsoRepository.deleteById(id);
	}

	//Gestione corsi pieni
	public void gestisciCorsoPieno(Long corsoId, int scelta) {
		Corso corso = corsoRepository.findById(corsoId)
			.orElseThrow(() -> new EntityNotFoundException("Corso non trovato"));

		switch (scelta) {
			case 1:
				dividiCorso(corso);
				break;
			case 2:
				aggiungiPostoExtra(corso);
				break;
			default:
				throw new IllegalArgumentException("Scelta non valida");
		}
	}

	//Dividere un corso in due gruppi più piccoli
	private void dividiCorso(Corso corso) {
		List<Studente> studenti = new ArrayList<>(corso.getStudenti());

		if (studenti.size() < 2) {
			throw new IllegalArgumentException("Impossibile dividere un corso con meno di 2 studenti.");
		}

		int metà = studenti.size() / 2;

		List<Studente> primoGruppo = new ArrayList<>(studenti.subList(0, metà));
		List<Studente> secondoGruppo = new ArrayList<>(studenti.subList(metà, studenti.size()));

		Corso corso1 = new Corso(corso, primoGruppo);
		Corso corso2 = new Corso(corso, secondoGruppo);

		corsoRepository.save(corso1);
		corsoRepository.save(corso2);
	}

	//Aggiungere un posto extra al corso pieno
	private void aggiungiPostoExtra(Corso corso) {
		System.out.println("Posto extra aggiunto al corso " + corso.getLingua());
	}

	public void generaCorsiAutomaticamente() {
		System.out.println("✅ Inizio generazione automatica corsi...");

		// 1. Recupera studenti disponibili con logging migliorato
		List<Studente> studentiDisponibili = new ArrayList<>(
			studenteRepository.findStudentiSenzaCorso().stream()
				.filter(s -> !s.isCorsoPrivato())
				.toList()
		);

		// Log studenti per lingua
		Map<String, Long> conteggioPerLingua = studentiDisponibili.stream()
			.collect(Collectors.groupingBy(Studente::getLinguaDaImparare, Collectors.counting()));
		System.out.println("Studenti disponibili per lingua: " + conteggioPerLingua);

		if (studentiDisponibili.isEmpty()) {
			System.out.println("⚠️ Nessuno studente disponibile per la generazione dei corsi.");
			return;
		}

		List<Corso> nuoviCorsi = new ArrayList<>();
		List<Corso> corsiEsistenti = corsoRepository.findByAttivoTrue();
		List<Set<Studente>> listaDiAttesa = new ArrayList<>();

		// 2. Precarica insegnanti e aule per performance
		List<Insegnante> tuttiInsegnanti = insegnanteRepository.findAll();
		List<Aula> tutteAule = aulaRepository.findAll();

		while (!studentiDisponibili.isEmpty()) {
			Studente studente = studentiDisponibili.get(0);
			System.out.println("\nElaborazione studente: " + studente.getNome() + " " + studente.getCognome() +
				" - Lingua: " + studente.getLinguaDaImparare() +
				" - Livello: " + studente.getLivello());

			// 3. Trova il primo giorno/orario compatibile con logging migliorato
			Optional<String> giornoCompatibile = studente.getGiorniPreferiti().stream().findFirst();
			Optional<String> orarioCompatibile = studente.getFasceOrariePreferite().stream().findFirst();

			if (giornoCompatibile.isEmpty() || orarioCompatibile.isEmpty()) {
				System.out.println("⚠️ Student senza giorni/orari preferiti - Skippato: " + studente.getId());
				studentiDisponibili.remove(studente);
				continue;
			}

			System.out.println("Tentativo creazione corso per: " + giornoCompatibile.get() + " " + orarioCompatibile.get());

			// 4. Trova gruppo compatibile con tolleranza migliorata
			List<Studente> gruppoCompatibile = studentiDisponibili.stream()
				.filter(s -> s.getLinguaDaImparare().equalsIgnoreCase(studente.getLinguaDaImparare()))
				.filter(s -> s.getLivello() == studente.getLivello())
				.filter(s -> Math.abs(s.getEta() - studente.getEta()) <= 2)
				.filter(s -> Objects.equals(s.getTipoCorsoGruppo(), studente.getTipoCorsoGruppo()))
				.filter(s -> s.getGiorniPreferiti().contains(giornoCompatibile.get()))
				.filter(s -> {
					boolean match = s.getFasceOrariePreferite().contains(orarioCompatibile.get());
					if (!match) {
						// Match più flessibile per orari simili (es. 16:00-18:00 e 16:30-18:30)
						return s.getFasceOrariePreferite().stream()
							.anyMatch(o -> {
								String oraInizioStudente = orarioCompatibile.get().substring(0, 5);
								String oraInizioO = o.substring(0, 5);
								return oraInizioStudente.equals(oraInizioO);
							});
					}
					return true;
				})
				.collect(Collectors.toList());

			gruppoCompatibile.add(studente);
			Set<Studente> gruppoUnico = new HashSet<>(gruppoCompatibile);

			if (gruppoUnico.size() < 3) {
				System.out.println("⚠️ Gruppo troppo piccolo (" + gruppoUnico.size() + " studenti), aggiunto alla lista di attesa per " +
					studente.getLinguaDaImparare() + " " + studente.getLivello());
				listaDiAttesa.add(gruppoUnico);
				studentiDisponibili.removeAll(gruppoUnico);
				continue;
			}

			System.out.println("Gruppo compatibile trovato: " + gruppoUnico.size() + " studenti per " +
				studente.getLinguaDaImparare() + " " + studente.getLivello());

			List<Studente> listaGruppo = new ArrayList<>(gruppoUnico);
			int index = 0;

			while (index < listaGruppo.size()) {
				// 5. Trova aula disponibile con query ottimizzata
				Optional<Aula> aulaDisponibile = tutteAule.stream()
					.filter(a -> a.getCapienzaMax() >= listaGruppo.size())
					.filter(a -> corsiEsistenti.stream().noneMatch(c ->
						c.getAula() != null &&
							c.getAula().getId().equals(a.getId()) &&
							(
								(c.getGiorno().equals(giornoCompatibile.get()) &&
									c.getOrario().equals(orarioCompatibile.get())) ||
									("2 volte a settimana".equalsIgnoreCase(studente.getTipoCorsoGruppo()) &&
										c.getSecondoGiorno() != null &&
										c.getSecondoOrario() != null &&
										c.getSecondoGiorno().equals(giornoCompatibile.get()) &&
										c.getSecondoOrario().equals(orarioCompatibile.get()))
							)
					))
					.findFirst();

				if (aulaDisponibile.isEmpty()) {
					System.out.println("⚠️ Nessuna aula disponibile per " + giornoCompatibile.get() + " " + orarioCompatibile.get());
					index = listaGruppo.size();
					continue;
				}

				int capienzaMassima = aulaDisponibile.map(Aula::getCapienzaMax).orElse(10);
				int fine = Math.min(index + capienzaMassima, listaGruppo.size());
				List<Studente> sottoGruppo = listaGruppo.subList(index, fine);

				// 6. Assegnazione insegnante migliorata
				Optional<Insegnante> insegnanteOpt = Optional.ofNullable(studente.getInsegnante())
					.map(i -> insegnanteRepository.findById(i.getId()).orElse(null))
					.or(() -> tuttiInsegnanti.stream()
						.filter(i -> i.getLingua().equalsIgnoreCase(studente.getLinguaDaImparare()))
						.filter(i -> i.getGiorniDisponibili() != null && i.getGiorniDisponibili().contains(giornoCompatibile.get()))
						.filter(i -> i.getFasceOrarieDisponibili() != null && i.getFasceOrarieDisponibili().contains(orarioCompatibile.get()))
						.findFirst());

				if (insegnanteOpt.isEmpty()) {
					System.out.println("⚠️ Nessun insegnante disponibile per " + studente.getLinguaDaImparare() +
						" il " + giornoCompatibile.get() + " alle " + orarioCompatibile.get());
					index = fine;
					continue;
				}

				// 7. Creazione corso
				Corso corso = new Corso();
				corso.setLingua(studente.getLinguaDaImparare());
				corso.setLivello(studente.getLivello());
				corso.setTipoCorso("GRUPPO");
				corso.setFrequenza(studente.getTipoCorsoGruppo());
				corso.setGiorno(giornoCompatibile.get());
				corso.setOrario(orarioCompatibile.get());
				corso.setInsegnante(insegnanteOpt.get());
				corso.setAula(aulaDisponibile.get());
				corso.setStudenti(new ArrayList<>(sottoGruppo));
				corso.setAttivo(true);

				// Gestione corsi bisettimanali
				if ("2 volte a settimana".equalsIgnoreCase(corso.getFrequenza())) {
					List<String> altriGiorni = studente.getGiorniPreferiti().stream()
						.filter(g -> !g.equals(giornoCompatibile.get()))
						.toList();

					List<String> altriOrari = studente.getFasceOrariePreferite().stream()
						.filter(o -> !o.equals(orarioCompatibile.get()))
						.toList();

					if (!altriGiorni.isEmpty() && !altriOrari.isEmpty()) {
						String secondoGiorno = altriGiorni.get(0);
						String secondoOrario = altriOrari.get(0);

						boolean aulaLiberaSecondoSlot = corsiEsistenti.stream()
							.noneMatch(c ->
								c.getAula() != null &&
									c.getAula().getId().equals(aulaDisponibile.get().getId()) &&
									((c.getGiorno().equals(secondoGiorno) && c.getOrario().equals(secondoOrario)) ||
										("2 volte a settimana".equalsIgnoreCase(c.getFrequenza()) &&
											c.getSecondoGiorno() != null &&
											c.getSecondoOrario() != null &&
											c.getSecondoGiorno().equals(secondoGiorno) &&
											c.getSecondoOrario().equals(secondoOrario)))
							);

						if (aulaLiberaSecondoSlot) {
							corso.setSecondoGiorno(secondoGiorno);
							corso.setSecondoOrario(secondoOrario);
							System.out.println("📆 Seconda lezione: " + secondoGiorno + " " + secondoOrario);
						} else {
							System.out.println("⚠️ Aula non disponibile per la seconda lezione, corso convertito a 1 volta/settimana");
							corso.setFrequenza("1 volta a settimana");
						}
					}
				}

				nuoviCorsi.add(corso);
				System.out.println("✅ Creato corso per " + corso.getLingua() + " " + corso.getLivello() +
					" con " + sottoGruppo.size() + " studenti");
				index = fine;
			}

			studentiDisponibili.removeAll(gruppoUnico);
		}

		if (!nuoviCorsi.isEmpty()) {
			corsoRepository.saveAll(nuoviCorsi);
			System.out.println("✅ Creati " + nuoviCorsi.size() + " nuovi corsi.");
			if (!listaDiAttesa.isEmpty()) {
				System.out.println("🔄 Tentativo di unire gruppi in lista di attesa...");
				gestisciListaDiAttesa(listaDiAttesa);
			}
		} else {
			System.out.println("⚠️ Nessun corso creato.");
		}
	}

	private void gestisciListaDiAttesa(List<Set<Studente>> listaDiAttesa) {
		System.out.println("\n🔄 Inizio gestione lista di attesa (" + listaDiAttesa.size() + " gruppi)");

		List<Corso> nuoviCorsiDaLista = new ArrayList<>();
		List<Corso> corsiEsistenti = corsoRepository.findByAttivoTrue();

		// Raggruppa gli studenti in lista d'attesa per lingua, livello e tipo corso
		Map<String, List<Studente>> studentiPerLinguaLivello = listaDiAttesa.stream()
			.flatMap(Set::stream)
			.collect(Collectors.groupingBy(
				s -> s.getLinguaDaImparare() + "_" + s.getLivello() + "_" + s.getTipoCorsoGruppo(),
				Collectors.toList()
			));

		studentiPerLinguaLivello.forEach((key, studenti) -> {
			if (studenti.size() >= 3) {
				System.out.println("🔍 Tentativo di creare corso da lista attesa: " + key + " (" + studenti.size() + " studenti)");

				// Trova giorni/orari comuni
				Map<String, Long> giorniComuni = studenti.stream()
					.flatMap(s -> s.getGiorniPreferiti().stream())
					.collect(Collectors.groupingBy(g -> g, Collectors.counting()));

				Map<String, Long> orariComuni = studenti.stream()
					.flatMap(s -> s.getFasceOrariePreferite().stream())
					.collect(Collectors.groupingBy(o -> o, Collectors.counting()));

				Optional<String> giornoOttimale = giorniComuni.entrySet().stream()
					.max(Map.Entry.comparingByValue())
					.map(Map.Entry::getKey);

				Optional<String> orarioOttimale = orariComuni.entrySet().stream()
					.max(Map.Entry.comparingByValue())
					.map(Map.Entry::getKey);

				if (giornoOttimale.isPresent() && orarioOttimale.isPresent()) {
					System.out.println("📅 Giorno ottimale: " + giornoOttimale.get());
					System.out.println("⏰ Orario ottimale: " + orarioOttimale.get());

					// Trova aula disponibile
					Optional<Aula> aulaDisponibile = aulaRepository.findAll().stream()
						.filter(a -> a.getCapienzaMax() >= studenti.size())
						.filter(a -> corsiEsistenti.stream().noneMatch(c ->
							c.getAula() != null &&
								c.getAula().getId().equals(a.getId()) &&
								c.getGiorno().equals(giornoOttimale.get()) &&
								c.getOrario().equals(orarioOttimale.get())
						))
						.findFirst();

					// Trova insegnante disponibile
					Optional<Insegnante> insegnanteDisponibile = insegnanteRepository.findAll().stream()
						.filter(i -> i.getLingua().equalsIgnoreCase(studenti.get(0).getLinguaDaImparare()))
						.filter(i -> i.getGiorniDisponibili().contains(giornoOttimale.get()))
						.filter(i -> i.getFasceOrarieDisponibili().contains(orarioOttimale.get()))
						.findFirst();

					if (aulaDisponibile.isPresent() && insegnanteDisponibile.isPresent()) {
						Corso corso = new Corso();
						corso.setLingua(studenti.get(0).getLinguaDaImparare());
						corso.setLivello(studenti.get(0).getLivello());
						corso.setTipoCorso("GRUPPO");
						corso.setFrequenza(studenti.get(0).getTipoCorsoGruppo());
						corso.setGiorno(giornoOttimale.get());
						corso.setOrario(orarioOttimale.get());
						corso.setInsegnante(insegnanteDisponibile.get());
						corso.setAula(aulaDisponibile.get());
						corso.setStudenti(new ArrayList<>(studenti));
						corso.setAttivo(true);

						nuoviCorsiDaLista.add(corso);
						System.out.println("✅ Creato corso dalla lista d'attesa per " + key + " con " + studenti.size() + " studenti");
					} else {
						System.out.println("⚠️ Impossibile creare corso per " + key +
							" - Aula disponibile: " + aulaDisponibile.isPresent() +
							", Insegnante disponibile: " + insegnanteDisponibile.isPresent());
					}
				} else {
					System.out.println("⚠️ Nessun giorno/orario comune sufficiente per " + key);
				}
			} else {
				System.out.println("ℹ️ Gruppo in lista d'attesa troppo piccolo (" + studenti.size() + " studenti) per " + key);
			}
		});

		if (!nuoviCorsiDaLista.isEmpty()) {
			corsoRepository.saveAll(nuoviCorsiDaLista);
			System.out.println("✅ Creati " + nuoviCorsiDaLista.size() + " nuovi corsi dalla lista d'attesa");
		} else {
			System.out.println("⚠️ Nessun corso creato dalla lista d'attesa");
		}
	}
	//Metodo per ottenere tutti i corsi non attivi
	public List<CorsoResponseDTO> getCorsiDisattivati() {
		List<Corso> corsi = corsoRepository.findByAttivoFalse();
		return corsi.stream().map(this::convertToResponseDTO).collect(Collectors.toList());
	}

	//Metodo per riattivare un corso
	public void riattivaCorso(Long id) {
		Corso corso = corsoRepository.findById(id)
			.orElseThrow(() -> new EntityNotFoundException("Corso non trovato con ID: " + id));

		if (corso.isAttivo()) {
			throw new IllegalStateException("Il corso è già attivo.");
		}

		//Controllo per evitare sovrapposizioni nell'aula
		List<Corso> corsiEsistenti = corsoRepository.findByAulaIdAndGiornoAndOrarioAndAttivoTrue(
			corso.getAula().getId(), corso.getGiorno(), corso.getOrario());

		if (!corsiEsistenti.isEmpty()) {
			throw new IllegalStateException("Impossibile riattivare il corso: l'aula è già occupata in quel giorno/orario.");
		}

		corso.setAttivo(true);
		corsoRepository.save(corso);
	}


	//Metodo per ottenere la lista di attesa raggruppata per corso
	public List<List<String>> getGruppiListaDiAttesa() {
		return listaDiAttesa.values().stream()
			.map(gruppo -> gruppo.stream()
				.map(Studente::getNome)
				.collect(Collectors.toList()))
			.collect(Collectors.toList());
	}


	//Metodo per ottenere la lista di attesa raggruppata per corso fittizio (o criterio)
	public List<StudenteResponseDTO> getListaDiAttesa() {
		return listaDiAttesa.values().stream()
			.flatMap(List::stream)
			.map(studente -> {
				StudenteResponseDTO dto = new StudenteResponseDTO();
				BeanUtils.copyProperties(studente, dto);
				return dto;
			})
			.collect(Collectors.toList());
	}
	
	public void aggiungiStudente(Long corsoId, Long studenteId) {
		Corso corso = corsoRepository.findById(corsoId)
			.orElseThrow(() -> new EntityNotFoundException("Corso non trovato con ID: " + corsoId));
		Studente studente = studenteRepository.findById(studenteId)
			.orElseThrow(() -> new EntityNotFoundException("Studente non trovato con ID: " + studenteId));

		// Aggiungi lo studente alla lista
		List<Studente> studenti = corso.getStudenti();
		if (!studenti.contains(studente)) {
			studenti.add(studente);
			corsoRepository.save(corso);
		} else {
			throw new IllegalArgumentException("Lo studente è già assegnato a questo corso.");
		}
	}


	//Metodo per convertire un Corso in CorsoResponseDTO
	public CorsoResponseDTO convertToResponseDTO(Corso corso) {
		CorsoResponseDTO dto = new CorsoResponseDTO();
		BeanUtils.copyProperties(corso, dto);


		// Aggiungi il campo "attivo"
		dto.setAttivo(corso.isAttivo());
		dto.setSecondoGiorno(corso.getSecondoGiorno());
		dto.setSecondoOrario(corso.getSecondoOrario());

		//Assegna manualmente l'insegnante
		if (corso.getInsegnante() != null) {
			InsegnanteResponseDTO insegnanteDTO = new InsegnanteResponseDTO();
			BeanUtils.copyProperties(corso.getInsegnante(), insegnanteDTO);
			dto.setInsegnante(insegnanteDTO);
		}

		//Assegna manualmente l'aula
		if (corso.getAula() != null) {
			AulaResponseDTO aulaDTO = new AulaResponseDTO();
			BeanUtils.copyProperties(corso.getAula(), aulaDTO);
			dto.setAula(aulaDTO);
		}

		//Mappa gli studenti in StudenteResponseDTO
		if (corso.getStudenti() != null && !corso.getStudenti().isEmpty()) {
			List<StudenteResponseDTO> studentiDTO = corso.getStudenti().stream().map(studente -> {
				StudenteResponseDTO sDTO = new StudenteResponseDTO();
				BeanUtils.copyProperties(studente, sDTO);
				return sDTO;
			}).collect(Collectors.toList());
			dto.setStudenti(studentiDTO);
		}

		return dto;
	}

}